---
layout    : post
title     : 程序员的视角：Java 线程
date      : 2014-03-30
author    : mindwind
categories: blog
tags      : Java 线程 thread
image     : /assets/article_images/2014-03-30.jpg
---

在我们开始谈线程之前，不得不提下进程。
无论进程还是线程都是很抽象的概念，有一个关于进程和线程很形象的比喻能帮我们更好的理解。

  > 进程就像个房子，房子是一个包含了特定属性的容器，例如空间大小、卧室数量等。  
  > 如果你也这样看的话，那么房子自己不会主动做任何事情，它是被动的对象。  
  > 而线程则像是房中的居住者，它是主动的对象——居住者要使用不同的房间、看电视、煮饭、洗澡等等。  
  > 房子占据着一块真实的土地，正像进程占据着内存。  
  > 而房子的居住者可以自由出入所有的房间，而进程中的线程也是类似的，可以自由访问任何进程占据的内存。  
  > 按照教科书上的定义，进程是资源管理的最小单位，线程是程序执行的最小单位。
  > 通过上面的比喻，我们可以更容易的理解进程和线程的关系。
  > 进程只是一个容器对象，它负责占据资源（内存地址、文件I/O），而线程共享进程的资源，作为CPU调度的基本单位可以被独立调度。

按照教科书上的定义，进程是资源管理的最小单位，线程是程序执行的最小单位。 通过上面的比喻，我们可以更容易的理解进程和线程的关系。 进程只是一个容器对象，它负责占据资源（内存地址、文件I/O），而线程共享进程的资源，作为CPU调度的基本单位可以被独立调度。


## 线程实现
回到我们的题目：Java 线程。 Java 作为一个跨平台的语言，自然要提供一个跨平台的线程实现。 线程按类型可以分为内核线程（Kernel-Level Thread）和用户线程（User Thread），分类的标准主要是线程的调度者在核内还是在核外。 早期时，一些操作系统因为没有提供线程的原生实现，所以早在JDK1.2之前，Java是基于用户线程来实现的。 用户线程是相对内核线程而言，内核线程自然是由操作系统内核支持的线程，由内核来管理和调度。 后来主流操作系统都支持了线程，因此现在Java都采用原生线程来实现了。

既然现在的 Java 线程都采用原生系统线程来实现，那么是否每个Java线程就对应一个系统内核线程？ 对sun jdk而言，在 Windows 和 Linux 中都是采用的一对一模型，Linux提供一种称为轻量级进程（LWP）的高级抽象来避免应用直接使用内核线程。 而在像Solaris这样的系统中则不一定了，因为它支持多对多模型。 不过对于底层系统的线程模型到底如何，对Java线程而言都是被屏蔽了的，jvm层面提供了一个统一的抽象线程模型。 下图展示了在Linux上Java线程实现的模型图

![](/assets/article_images/2014-03-30-2.png)


## 线程数量
曾经碰到一个问题，Java程序运行中抛出一个OOM错误如下：

`Java.lang.OutOfMemoryError: unable to create new native thread`

这个问题的原因可能有两种，一种是内存真的不足了，自然无法再创建线程。 另外一种其实是来自操作系统的限制，比如在 Linux 中，Java 线程会映射为轻量级进程，那么创建线程的数量自然会受到系统进程数量等资源约束的限制。

对于一个 Java 进程到底能创建多少线程呢，一般我们按经验线程都是在几十到几百之间，顶多 1、2k 了。 这是为什么呢？Java 有个启动参数-Xss1m表明每个线程栈大小为1m，那么对内存一般 2G 的话，总线程数达到 2k 感觉上都是不可能的。 但实际上做个实验在循环中不断创建新线程，可以不断创建多达几万的线程，这又是为什么？ 原因是新创建的线程其实仅仅分配了内存地址空间，但并没有实际去占用那1m的栈空间，栈空间是在线程使用时才去实际占用的。 所以经验是对的，一般对 2G 的堆内存空间线程数量根据应用类型在几十到几百之间是合适的。


## 线程状态
Java 定义了6种线程状态，任一时刻一个线程处于其中一种状态，其状态转换关系如下图：

![](/assets/article_images/2014-03-30-1.png)

  1. `NEW`  
     新创建未启动的线程处于该状态
  2. `RUNNABLE`  
     调用了start()方法后，线程进入RUNNABLE状态
  3. `WAITING`  
     不设置timeout的Object.wati()、Thread.join()等方法会让线程进入无限等待，需要等待其他线程显式的唤醒。
  4. `TIMED_WAITING`  
     Thead.sleep()或设置了timeout的Object.wati()、Thread.join()等方法让线程进入限期等待。
  5. `BLOCKED`  
     阻塞状态，线程在等待进入同步区域。
  6. `TERMINATED`  
     线程执行结束，终止状态。

从上面的状态图可以看出，线程从新建、执行到结束是单向的，期间可能会经历等待和阻塞状态，线程执行结束进入终止状态后将不能再重复使用。 任何时候一个 CPU 核只能执行一个线程，也就是说同时并行运行的线程数与 CPU 核数相等。 在操作系统内核层面，线程只有分配了 CPU 的执行时间片，才算处于 `RUNNING` 状态。 而当有大于 CPU 核数的线程需要执行，没有分配到 CPU 执行时间片的线程则处于 `READY` 状态。 `RUNNING` 和 `READY` 都是线程在内核的状态，同时映射到 Java 的 `RUNNABLE` 状态。 `RUNNABLE` 正如其名，表示可运行的状态，并非正在运行的状态。


## 线程池
Java 编程不可避免的要使用线程，而使用线程更常见的方式是使用线程池。 说起池这个东西，我们应该比较熟悉，例如：连接池。 其实池就是一个容器，里面有一堆预先创建好的对象，我们就称其为对象池，而当这个对象具体为线程，那就是线程池了。 前面讲线程状态说过，线程执行从 run() 方法退出就会进入终止状态，那么这个线程就消亡了，不能再复用。 线程池的概念就是要复用线程，避免创建开销，那么如何复用呢，其实就是要让池中的线程不用从run()方法中退出。 所以为了复用线程，池的实现会与一个阻塞队列结合，空闲时线程阻塞在队列上等待任务到来，任务执行结束后再重新阻塞，永远不会退出。

jdk1.5 引入了 `Java.util.concurrent` 并发包后，我们可以很方便的通过 `ThreadPoolExecutor` 来创建线程池。

{% highlight Java %}
public ThreadPoolExecutor
(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,
    ThreadFactory threadFactory,
    RejectedExecutionHandler handler
)
{% endhighlight %}

如上所示的构造方法中，`corePoolSize`、`maximumPoolSize` 和 `workQueue` 的关系一直让人容易误解。 当待执行任务数大于 `corePoolSize` 时，多出的任务请求会被放进 `workQueue` 中等待执行，直到 `workQueue` 满了后 才会继续启动新线程直到总线程数达到 `maximumPoolSize` 的大小，其示意图如下。

![](/assets/article_images/2014-03-30-3.png)
